# --------------------------------------------------------
# 编译器设置
# --------------------------------------------------------
CC = gcc              # 设置编译器为 gcc
CFLAGS = -I inc       # 设置编译选项，-I 后跟的是头文件目录 inc
LDFLAGS =             # 链接选项，这里暂时没有指定，后续可以根据需要添加

# --------------------------------------------------------
# 文件目录设置
# --------------------------------------------------------
OBJ_DIR = build       # 目标文件存放的目录，目标文件会保存在 build 目录下
SRC_DIR = src         # 源文件存放的目录，源文件在 src 目录下
APP_DIR = app         # 应用程序的源文件目录，main.c 在 app 目录下
INC_DIR = inc         # 头文件目录，头文件在 inc 目录下

# --------------------------------------------------------
# 目标文件和最终可执行文件设置
# --------------------------------------------------------
OBJ_FILES = $(OBJ_DIR)/mat.o $(OBJ_DIR)/test.o  # 目标文件列表，mat.o 和 test.o
TARGET = test            # 最终生成的可执行文件名是 test

# --------------------------------------------------------
# 默认目标
# --------------------------------------------------------
# 如果没有指定目标，make 会默认执行这里的 'all' 目标
all: $(TARGET)           # 目标是生成可执行文件 test

# --------------------------------------------------------
# 编译 mat.c 生成 mat.o 目标文件
# --------------------------------------------------------
# $(OBJ_DIR)/mat.o: $(SRC_DIR)/mat.c
# 这表示，当 mat.o 目标文件需要更新时，依赖 mat.c 文件
# 然后使用 gcc 编译 mat.c 为 mat.o
$(OBJ_DIR)/mat.o: $(SRC_DIR)/mat.c
	$(CC) -c -o $@ $< $(CFLAGS)  # $@ 代表目标文件（mat.o），$< 代表第一个依赖文件（mat.c）

# --------------------------------------------------------
# 编译 main.c 生成 test.o 目标文件
# --------------------------------------------------------
# $(OBJ_DIR)/test.o: $(APP_DIR)/main.c
# 这表示，当 test.o 目标文件需要更新时，依赖 main.c 文件
# 然后使用 gcc 编译 main.c 为 test.o
$(OBJ_DIR)/test.o: $(APP_DIR)/main.c
	$(CC) -c -o $@ $< $(CFLAGS)  # $@ 代表目标文件（test.o），$< 代表第一个依赖文件（main.c）

# --------------------------------------------------------
# 链接生成最终可执行文件
# --------------------------------------------------------
# $(TARGET): $(OBJ_FILES)
# 这表示，目标 test 依赖目标文件 $(OBJ_FILES)，
# make 会在 $(OBJ_FILES) 更新后执行链接操作，生成可执行文件 test
$(TARGET): $(OBJ_FILES)
	$(CC) -o $(TARGET) $(OBJ_FILES) $(LDFLAGS)  # 使用 gcc 链接生成最终的可执行文件 test

# --------------------------------------------------------
# 清理生成的中间文件和可执行文件
# --------------------------------------------------------
# clean 目标会删除所有的目标文件和可执行文件，
# 这通常用于清理项目，确保下一次编译时从头开始
clean:
	rm -f $(OBJ_DIR)/*.o $(TARGET)  # 删除所有目标文件（*.o）和最终可执行文件（test）

# --------------------------------------------------------
# .PHONY 声明
# --------------------------------------------------------
# .PHONY 用来声明伪目标（伪目标是没有实际文件与之对应的目标）
# 确保 make 不会将 clean 当作文件名来处理，即使项目中有名为 clean 的文件
.PHONY: all clean

